## 先明确：STW 到底是什么？
STW 是 JVM 在执行垃圾回收（GC）过程中，强制暂停所有用户线程（非 GC 线程）的 “短暂停顿” 机制，其核心目的是：
避免 GC 线程与用户线程同时操作堆内存（如用户线程创建对象、GC 线程回收对象），导致堆内存数据结构（如对象引用链）混乱，最终保证 GC 回收的准确性。
需要纠正一个常见误区：STW 不是 “整个 GC 过程都停”，而是 GC 中的 “关键阶段” 才会触发

## 核心：STW 对系统性能的影响（结合业务场景）
STW 的危害本质是 “用户线程暂停 → 业务处理中断”，但不同业务场景对 “中断” 的敏感度完全不同 —— 蚂蚁金服的面试题正是想考察 “从技术到业务的映射能力”。以下是 3 个典型场景的深度分析：
高并发金融交易系统（如支付宝支付、基金申购）
业务特点：
要求 “低响应时间（RT < 50ms）+ 高可用性（99.99%+）”，每笔交易涉及资金流转，一旦超时可能导致 “用户重复支付”“订单状态不一致”，甚至触发资损风险。
STW 的具体影响：
若 STW 时长超过业务超时阈值（如 100ms），会直接导致：
   1. 支付请求超时：用户点击 “确认支付” 后，后端线程因 STW 暂停，无法及时返回支付结果，前端触发重试逻辑，可能产生 “一笔订单扣两次款” 的问题；
   2. 交易队列堆积：高并发时段（如双十一、基金开售），每秒数千笔请求涌入，STW 期间请求无法处理，队列长度暴涨，即使 STW 结束后，也可能因队列溢出导致请求丢失；
   3. 监控告警风暴：系统通常配置 “RT 超过 100ms 告警”“请求失败率 > 0.1% 告警”，STW 会直接触发大量告警，干扰运维人员对真实故障的判断。
实例参考：
早期某支付系统使用 CMS GC，Old 区内存碎片化严重，触发 “重新标记（Remark）” 阶段时 STW 长达 150ms，导致某时段支付失败率从 0.01% 飙升至 2.3%，最终通过调整 CMS 触发阈值（-XX:CMSInitiatingOccupancyFraction）和内存分代大小缓解。

## cms\g1\zgc什么时候会STW

1. CMS（Concurrent Mark Sweep）收集器的 STW 阶段
CMS 是早期为追求 “低延迟” 设计的收集器，核心特点是 “大部分工作与用户线程并发执行”，但仍有两个不可避免的 STW 阶段：

初始标记（Initial Mark）
作用：标记 “GC Roots 直接关联的对象”（如虚拟机栈引用的对象、静态变量引用的对象），是整个标记过程的起点。
STW 原因：需快速确定初始标记集合，避免用户线程修改根对象引用导致标记错误。
时长：极短（通常毫秒级），因为仅标记直接关联对象，不遍历整个引用链。
重新标记（Remark）
作用：修正并发标记阶段因用户线程运行导致的 “标记变动”（如并发标记时，用户线程删除了某个对象的引用，或新增了引用）。
STW 原因：需要重新扫描 “在并发标记期间被修改的对象”，确保标记结果准确，此过程必须暂停用户线程，否则会持续产生新的变动。
时长：比初始标记长（通常十到几十毫秒），取决于并发标记期间用户线程修改的对象数量（修改越多，重新标记耗时越长）。

补充：CMS 的 “并发标记” 和 “并发清除” 阶段与用户线程并行，无 STW；但 CMS 存在 “内存碎片” 问题，最终可能触发 Full GC（Serial Old 收集器执行），此时会产生长时间 STW（百毫秒到秒级）。
2. G1（Garbage-First）收集器的 STW 阶段
G1 是面向 “中大型堆” 的收集器，采用 “区域化分代” 思想，兼顾吞吐量和延迟，其 STW 阶段比 CMS 更复杂：

年轻代 GC（Young GC）中的 STW
作用：回收 Young 区（Eden 区 + Survivor 区）的对象，将存活对象复制到 Survivor 区或 Old 区。
STW 原因：Young 区对象存活率低，采用 “复制算法” 高效回收，需暂停用户线程避免复制过程中对象引用被修改。
时长：毫秒级（通常 < 50ms），取决于 Young 区大小和对象存活率。

混合 GC 中的初始标记（Initial Mark）
作用：标记 GC Roots 直接关联的对象（与 CMS 类似），同时会触发一次 Young GC（因此 STW 包含 Young GC 的停顿）。
STW 原因：与 CMS 初始标记逻辑一致，需快速确定根对象集合。
时长：略长于单纯的 Young GC，因增加了根对象标记步骤。

混合 GC 中的最终标记（Final Mark）
作用：修正并发标记阶段用户线程导致的标记变动（类似 CMS 的重新标记），但 G1 引入了 “SATB（Snapshot-At-The-Beginning）” 机制，减少需重新扫描的对象数量。
STW 原因：需确保标记结果准确，避免并发修改导致的遗漏。
时长：通常比 CMS 的重新标记短（因 SATB 优化），但仍为毫秒级。

转移回收（Evacuation）
作用：在混合 GC 中，回收部分 Old 区（优先回收垃圾比例高的区域），将存活对象复制到新的区域（消除碎片）。
STW 原因：采用复制算法，需暂停用户线程避免复制过程中对象引用变化。
时长：毫秒级，G1 会通过 -XX:MaxGCPauseMillis（默认 200ms）控制此阶段最大停顿时间，动态调整回收的区域数量。

补充：若 G1 的 “混合回收” 无法跟上对象分配速度，会触发 Full GC（Serial Old 执行），导致长时间 STW（需尽量避免）。

3. ZGC（Z Garbage Collector）的 STW 阶段
ZGC 是为 “超低延迟” 和 “超大堆” 设计的收集器（支持 TB 级内存），通过 “着色指针” 和 “读屏障” 技术，将几乎所有工作与用户线程并发执行，仅存两个极短的 STW 阶段：

初始标记（Initial Mark）
作用：标记 GC Roots 直接关联的对象（与 CMS、G1 逻辑一致）。
STW 原因：快速确定根对象集合，作为后续并发标记的起点。
时长：微秒级到毫秒级（通常 < 1ms），因 ZGC 处理的根对象数量更少（通过优化根扫描逻辑）。
最终标记（Final Mark）
作用：处理初始标记后根对象的少量变动，以及清理并发标记阶段的遗留工作。
STW 原因：确保标记结果最终准确，此阶段工作量极少。
时长：与初始标记相当（通常 <1ms），是 ZGC 实现 “超低延迟” 的核心体现。




## 核心优化方向有 3 个：
选对 GC 收集器：
高并发低延迟场景（支付、风控）：优先用 ZGC/Shenandoah（微秒级 STW）；
中大型堆场景（10~100GB）：用 G1 GC，并通过 -XX:MaxGCPauseMillis=20 控制目标停顿时间；
批处理场景：用 Parallel GC（吞吐量优先，STW 时长可接受）。
合理配置堆内存与分代：
堆内存：避免过大（建议单 JVM 堆不超过 32GB，超过用 ZGC），同时保证 Young 区足够大（占堆的 30%~50%），减少 Minor GC 次数；
避免大对象：通过 -XX:PretenureSizeThreshold 限制大对象直接进入 Old 区，减少 Old 区 GC 压力（大对象回收耗时更长）。
监控与提前调优：
实时监控：通过 JVM 工具（JVisualVM、Arthas）或监控平台（Prometheus + Grafana）跟踪 GC 指标（STW 时长、GC 次数、堆内存使用率）；
日志分析：开启 GC 日志（-Xlog:gc*:file=gc.log:time,level,tags:filecount=5,filesize=100m），提前识别 STW 增长趋势（如 Old 区使用率每周上涨 5%，需提前扩容或调优）。
