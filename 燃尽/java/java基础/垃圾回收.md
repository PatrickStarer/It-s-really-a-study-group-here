## cms垃圾收集器用的 标记 - 清除算法

* 老年代采用标记 - 清除算法（Mark-Sweep），不移动存活对象，仅回收垃圾。
* 工作流程（老年代回收）：
* 初始标记（STW）：标记根对象直接引用的老年代对象，耗时极短。
* 并发标记：与应用线程并行，遍历标记所有可达对象（存活对象）。
* 重新标记（STW）：修正并发标记期间因应用线程修改引用导致的标记偏差，停顿时间短于初始标记。
* 并发清除：与应用线程并行，回收未标记的垃圾对象，不整理内存。
*
缺点：内存碎片、需要更大堆内存、CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(
CPU数量+3) / 4

## G1垃圾收集器用的标记 - 整理算法、复制算法、分区算法

G1（Garbage-First）是基于 “分代 + Region” 的收集器，核心目标是平衡延迟与吞吐量，依赖Remembered
Set和写屏障跟踪跨区域引用，执行过程包括年轻代回收（Young GC）、并发标记、混合回收（Mixed GC） 三个主要阶段。

1. G1 的核心组件
   Region：堆内存划分为多个大小相等的独立 Region（1-32MB），动态标记为 Eden、Survivor、老年代。
   Remembered Set（RS）：每个 Region 维护一个 RS，记录 “其他 Region 对本 Region 对象的引用”（跨 Region 引用），避免回收时全堆扫描。
   写屏障（Store Barrier）：当应用线程修改对象引用（如a.b = c）时触发，用于更新 RS（若引用跨 Region，则记录到对应 Region 的 RS
   中）。
2. G1 的完整执行流程
   1. 年轻代回收（Young GC）
   触发条件：Eden Region 满时触发。<br>
   范围：回收所有 Eden Region + 部分 Survivor Region。
   流程（STW 阶段）：
   根扫描：从根对象（栈引用、静态变量等）出发，标记年轻代中所有存活对象。
   处理跨代引用：通过 Eden/Survivor Region 的 RS，找到老年代对年轻代对象的引用（这些对象需标记为存活）。
   复制存活对象：将存活对象复制到新的 Survivor Region（或晋升到老年代，若年龄达标）。
   清空旧 Region：原 Eden 和 Survivor Region 标记为空闲，等待复用。
   2. 并发标记（全堆标记）
   触发条件：老年代占比达阈值（默认 45%）时触发，为混合回收做准备。
   流程：
   初始标记（STW）：标记根对象直接引用的老年代对象（极短，几十微秒）。
   并发标记：与应用线程并行，遍历全堆对象，标记存活对象（依赖 RS 跟踪跨 Region 引用，避免全堆扫描）。
   最终标记（STW）：处理并发标记期间因应用线程修改引用导致的 “漏标” 对象（几百微秒到几毫秒）。
   清理：统计各 Region 的垃圾占比，优先选择垃圾多的 Region（Garbage-First）。
   3. 混合回收（Mixed GC）
   触发条件：并发标记完成后，若老年代垃圾占比高则触发。
   范围：回收所有年轻代 Region + 部分高垃圾占比的老年代 Region。
   流程（STW 阶段）：
   选择 Region：根据 “成本模型” 选择回收时间总和不超过-XX:MaxGCPauseMillis（默认 200ms）的老年代 Region。
   复制存活对象：将选中 Region 的存活对象复制到新 Region（年轻代→Survivor，老年代→新老年代 Region）。
   更新引用：修正所有指向被回收 Region 的引用（依赖 RS 找到这些引用）。
   清空旧 Region：标记为空闲。
3. G1 中写屏障与 Remembered Set 的协作（示例）
   假设有如下代码：

```java
class A {
    B b;
}

class B {
}

public class G1Demo {
    public static void main(String[] args) {
        A a = new A(); // a在Eden Region（R1）
        B b = new B(); // b在老年代Region（R2）
        a.b = b; // 跨Region引用：R1的a引用R2的b → 触发写屏障
    }
} 
```

写屏障触发：执行a.b = b时，写屏障检测到 “Eden Region（R1）→ 老年代 Region（R2）” 的跨引用。
更新 Remembered Set：写屏障将该引用记录到 R1 的 RS 中（标记 “R1 有来自 R2 的引用”）。
作用：后续回收 R1 时，G1 只需扫描 R1 的 RS，就能找到被老年代引用的存活对象a，无需扫描整个老年代。

* 优点：无内存碎片、控制stw时间（根据预设的 “最大停顿目标”（-XX:MaxGCPauseMillis，默认 200ms），动态选择回收的 Region 数量）

## g1相对于cms的优势

* stw可控：根据设置的stw时间 决定扫描region的数量，从而实现stw时间可控；
* 内存碎片：G1 采用标记 - 整理算法和复制算法结合的方式回收垃圾，在清理完垃圾后，会再整理对象位置。

## ZGC jdk15正式版
ZGC 是低延迟收集器，目标是 “STW<10ms”+“支持 TB 级内存”，
核心依赖颜色指针和读屏障，几乎不用写屏障和 Remembered Set，执行过程包括初始标记、并发标记、并发重定位等阶段。
1. ZGC 的核心组件
   动态 Region：堆划分为小（2MB）、中（32MB）、大（可变）Region，无固定分代（可选分代）。
   颜色指针：64 位地址高 4 位存储对象状态（未标记、已标记、待重定位、已重定位），替代对象头标记。
   读屏障（Load Barrier）：应用线程读取引用时触发，修正 “待重定位” 指针为新地址（支持并发移动对象）。
   Relocation Map：记录 “旧地址→新地址” 映射，供读屏障查询。
2. ZGC 的完整执行流程
   1. 初始标记（Initial Mark，STW）
   触发条件：堆占比达阈值（默认 95%）时触发。
   流程：从根对象出发，标记直接引用的对象（仅标记根可达的第一层对象），通过颜色指针标记为 “已标记”（STW，几十微秒）。
   2. 并发标记（Concurrent Mark）
   流程：与应用线程并行，遍历全堆对象，通过颜色指针标记所有存活对象（未标记→已标记）。无需 RS，通过颜色指针直接判断跨 Region 引用状态。
   3. 并发预备重定位（Concurrent Prepare for Relocation）
   流程：选择高垃圾占比的 Region 作为 “重定位集”，为其中存活对象分配新地址，将旧地址颜色设为 “待重定位”，并记录到 Relocation Map（旧→新地址）。
   4. 并发重定位（Concurrent Relocate）
   流程：与应用线程并行，将 “重定位集” 中存活对象复制到新地址。应用线程读取 “待重定位” 指针时，读屏障自动修正为新地址（透明化处理）。
   5. 并发重映射（Concurrent Remap）
   流程：后台线程异步更新所有引用为新地址，删除 Relocation Map 记录（不影响应用线程）。
   6. 最终标记（Final Mark，STW）
   流程：处理并发标记遗漏的根对象（如 JNI 引用），STW 极短（几百微秒）。
3. ZGC 中颜色指针与读屏障的协作（示例）
   沿用 G1 的类结构，代码如下：

```java
public class ZGCDemo {
    public static void main(String[] args) {
        A a = new A(); // a在Region R1（地址0x1000）
        B b = new B(); // b在Region R2（地址0x3000）
        a.b = b; // a.b存储指针0x3000（指向b）

        // ZGC触发回收，将b从0x3000移动到0x4000（并发重定位阶段）
        // 应用线程读取a.b（触发读屏障）
        B b2 = a.b;
        System.out.println(b2); //期望访问新地址0x4000的b
    }
}
```
颜色指针设置：ZGC 在预备重定位阶段，将 b 的旧地址0x3000颜色设为 “待重定位”（高 4 位0010），Relocation Map 记录0x3000→0x4000。
读屏障触发：应用线程执行a.b时，读屏障检测到0x3000是 “待重定位”。
指针修正：读屏障查询 Relocation Map，将a.b的指针修正为0x4000（颜色设为 “已重定位”），应用线程最终访问新地址的 b。


## g1咋在年轻代用的复制算法
* 标记存活对象：从根对象出发，标记 Eden 和 Survivor Region 中所有存活的对象（主要是新创建的短期对象）。
* 复制存活对象：将所有存活对象复制到新的 Survivor Region（或晋升到老年代 Region，对于达到年龄阈值的对象）。
* 清空原区域：复制完成后，原 Eden 和 Survivor Region 被标记为 “空闲”，可重新分配给新对象。

## 垃圾回收器底层标记算法实现 三色标记法

## zgc比g1快在哪里
G1 通过 “STW+Remembered Set” 实现可控延迟，而 ZGC 通过 “颜色指针 + 读屏障” 实现无感知并发移动，这是两者性能差异的核心原因

### g1的Remembered Set（RS） 和 ZGC 的 Relocation Map 
1. G1 的 Remembered Set（RS）： 长期存在（与 Region 同生命周期），只要 Region 被使用，其 RS 就需要持续维护。
2. 每次应用线程修改跨 Region 引用（如a.b = c）时，写屏障都要更新 RS，这会增加应用线程的执行时间（额外消耗 5%-15% 的 CPU）。

3. ZGC 的 Relocation Map： 只有被清理的region会有，在整理阶段由 GC 线程构建，无需应用线程参与；重定位结束后立即释放，无长期维护成本。
4. 在读对象时，如果发现指针颜色变化，读屏障查询 Relocation Map，将指针修正为对象移动后的正确地址。

### 状态标记方法
1.  ZGC 的颜色指针：
   64 位指针的高几位（如 4 位）用于存储状态（颜色），而指针本身通常存储在CPU 缓存中（应用线程频繁访问的引用会被加载到 L1/L2 缓存）。
   例如：变量a指向对象obj，a的值（指针）存放在栈内存，而栈内存通常被 CPU 缓存缓存，因此读取指针的颜色位只需访问缓存（纳秒级，约 1-10ns）。
   G1 的对象头标记：
   G1 将对象状态（如是否存活）存储在对象头中，而对象头位于堆内存。堆内存容量大，且对象分散存储，CPU 缓存很难缓存所有对象头，因此读取状态需要访问主存（微秒级，约 100-200ns）。
   两者的访问延迟相差10-100 倍。
2. 无需 “跨内存访问” 的额外开销
   ZGC 判断状态时，只需读取指针本身（已在缓存中），无需访问对象所在的堆内存，避免了 “从缓存到主存” 的耗时加载。
   G1 判断状态时，必须先通过指针找到堆中的对象，再读取对象头的标记位，这需要至少一次 “指针→堆内存” 的跨区域访问（耗时且可能触发缓存未命中）。
3. 并发场景下的无锁优势
   ZGC 的颜色位修改是对指针的直接操作，而指针通常是线程私有的（如局部变量的引用），修改时无需加锁或同步（无并发冲突）。
   G1 的对象头可能被多个线程同时访问（如锁竞争、GC 标记），修改标记位时可能需要加锁或使用原子操作，进一步增加开销。
