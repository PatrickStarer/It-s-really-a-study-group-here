## cms垃圾收集器用的 标记 - 清除算法

* 老年代采用标记 - 清除算法（Mark-Sweep），不移动存活对象，仅回收垃圾。
* 工作流程（老年代回收）：
* 初始标记（STW）：标记根对象直接引用的老年代对象，耗时极短。
* 并发标记：与应用线程并行，遍历标记所有可达对象（存活对象）。
* 重新标记（STW）：修正并发标记期间因应用线程修改引用导致的标记偏差，停顿时间短于初始标记。
* 并发清除：与应用线程并行，回收未标记的垃圾对象，不整理内存。
*
缺点：内存碎片、需要更大堆内存、CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(
CPU数量+3) / 4

## G1垃圾收集器用的标记 - 整理算法、复制算法、分区算法

G1（Garbage-First）是基于 “分代 + Region” 的收集器，核心目标是平衡延迟与吞吐量，依赖Remembered
Set和写屏障跟踪跨区域引用，执行过程包括年轻代回收（Young GC）、并发标记、混合回收（Mixed GC） 三个主要阶段。

1. G1 的核心组件
   Region：堆内存划分为多个大小相等的独立 Region（1-32MB），动态标记为 Eden、Survivor、老年代。
   Remembered Set（RS）：每个 Region 维护一个 RS，记录 “其他 Region 对本 Region 对象的引用”（跨 Region 引用），避免回收时全堆扫描。
   写屏障（Store Barrier）：当应用线程修改对象引用（如a.b = c）时触发，用于更新 RS（若引用跨 Region，则记录到对应 Region 的 RS
   中）。
2. G1 的完整执行流程
   1. 年轻代回收（Young GC）
   触发条件：Eden Region 满时触发。<br>
   范围：回收所有 Eden Region + 部分 Survivor Region。
   流程（STW 阶段）：
   根扫描：从根对象（栈引用、静态变量等）出发，标记年轻代中所有存活对象。
   处理跨代引用：通过 Eden/Survivor Region 的 RS，找到老年代对年轻代对象的引用（这些对象需标记为存活）。
   复制存活对象：将存活对象复制到新的 Survivor Region（或晋升到老年代，若年龄达标）。
   清空旧 Region：原 Eden 和 Survivor Region 标记为空闲，等待复用。
   2. 并发标记（全堆标记）
   触发条件：老年代占比达阈值（默认 45%）时触发，为混合回收做准备。
   流程：
   初始标记（STW）：标记根对象直接引用的老年代对象（极短，几十微秒）。
   并发标记：与应用线程并行，遍历全堆对象，标记存活对象（依赖 RS 跟踪跨 Region 引用，避免全堆扫描）。
   最终标记（STW）：处理并发标记期间因应用线程修改引用导致的 “漏标” 对象（几百微秒到几毫秒）。
   清理：统计各 Region 的垃圾占比，优先选择垃圾多的 Region（Garbage-First）。
   3. 混合回收（Mixed GC）
   触发条件：并发标记完成后，若老年代垃圾占比高则触发。
   范围：回收所有年轻代 Region + 部分高垃圾占比的老年代 Region。
   流程（STW 阶段）：
   选择 Region：根据 “成本模型” 选择回收时间总和不超过-XX:MaxGCPauseMillis（默认 200ms）的老年代 Region。
   复制存活对象：将选中 Region 的存活对象复制到新 Region（年轻代→Survivor，老年代→新老年代 Region）。
   更新引用：修正所有指向被回收 Region 的引用（依赖 RS 找到这些引用）。
   清空旧 Region：标记为空闲。
3. G1 中写屏障与 Remembered Set 的协作（示例）
   假设有如下代码：

```java
class A {
    B b;
}

class B {
}

public class G1Demo {
    public static void main(String[] args) {
        A a = new A(); // a在Eden Region（R1）
        B b = new B(); // b在老年代Region（R2）
        a.b = b; // 跨Region引用：R1的a引用R2的b → 触发写屏障
    }
} 
```

写屏障触发：执行a.b = b时，写屏障检测到 “Eden Region（R1）→ 老年代 Region（R2）” 的跨引用。
更新 Remembered Set：写屏障将该引用记录到 R1 的 RS 中（标记 “R1 有来自 R2 的引用”）。
作用：后续回收 R1 时，G1 只需扫描 R1 的 RS，就能找到被老年代引用的存活对象a，无需扫描整个老年代。

* 优点：无内存碎片、控制stw时间（根据预设的 “最大停顿目标”（-XX:MaxGCPauseMillis，默认 200ms），动态选择回收的 Region 数量）

## g1相对于cms的优势

* stw可控：根据设置的stw时间 决定扫描region的数量，从而实现stw时间可控；
* 内存碎片：G1 采用标记 - 整理算法和复制算法结合的方式回收垃圾，在清理完垃圾后，会再整理对象位置。

## ZGC jdk15正式版
ZGC 是低延迟收集器，目标是 “STW<10ms”+“支持 TB 级内存”，
核心依赖颜色指针和读屏障，几乎不用写屏障和 Remembered Set，执行过程包括初始标记、并发标记、并发重定位等阶段。
1. ZGC 的核心组件
   动态 Region：堆划分为小（2MB）、中（32MB）、大（可变）Region，无固定分代（可选分代）。
   颜色指针：64 位地址高 4 位存储对象状态（未标记、已标记、待重定位、已重定位），替代对象头标记。
   读屏障（Load Barrier）：应用线程读取引用时触发，修正 “待重定位” 指针为新地址（支持并发移动对象）。
   Relocation Map：记录 “旧地址→新地址” 映射，供读屏障查询。
   ZGC 的核心创新是颜色指针（Colored Pointers），它利用 64 位地址的高 4 位存储对象状态（“颜色”），通过状态的动态转换驱动垃圾回收流程。ZGC 定义了 4 种核心颜色状态：
2. 颜色指针状态
未标记（Untagged）：0000，对象未被 GC 标记，可能是垃圾。
已标记（Marked）：0001，对象被标记为存活。
待重定位（Relocating）：0010，对象正在从旧地址移动到新地址。
已重定位（Relocated）：0011，对象已移动到新地址，旧地址仅作为 “转发指针”。

下面结合颜色指针的状态变化，详细拆解 ZGC 的主要工作流程：
一、初始标记（Initial Mark，STW）
目标：标记根对象直接引用的第一层对象，为并发标记打基础。
颜色指针变化：

根对象（如栈引用、静态变量）直接指向的对象，其指针颜色从未标记（0000） 改为已标记（0001）。
其他对象仍保持未标记（0000）。

过程：

暂停所有应用线程（STW，仅几十微秒）。
从根对象出发，遍历直接引用的对象（如a = new A()中，根引用a指向的A对象）。
将这些对象的指针颜色设为 “已标记（0001）”，表示它们是存活的。

示例：

根引用s指向对象obj（地址0x1000，初始颜色0000_0000_1000）。
初始标记后，obj的指针颜色变为0001_0000_1000（已标记）。
二、并发标记（Concurrent Mark）
目标：遍历全堆，标记所有存活对象（根可达对象）。
颜色指针变化：

所有被根可达的对象，指针颜色从未标记（0000） 改为已标记（0001）。
未被标记的对象（颜色仍为 0000）将被视为垃圾。

过程：

恢复应用线程，GC 线程与应用线程并行执行。
GC 线程从 “已标记” 对象出发，递归遍历所有引用的对象：
若对象指针为 “未标记（0000）”，则改为 “已标记（0001）”；
若已为 “已标记（0001）”，则跳过（避免重复标记）。
应用线程修改引用时（如a.b = c），ZGC 无需特殊处理（因颜色指针直接记录状态，无需 Remembered Set）。

核心优势：

标记仅修改指针颜色（在 CPU 缓存中操作），无需访问对象头（堆内存），速度极快。
三、并发预备重定位（Concurrent Prepare for Relocation）
目标：选择待回收的 Region（重定位集），为存活对象分配新地址，准备移动。
颜色指针变化：

重定位集中的 “已标记” 对象，旧地址指针颜色从已标记（0001） 改为待重定位（0010）。
为这些对象分配新地址（新地址初始颜色为已重定位（0011））。

过程：

GC 线程统计各 Region 的垃圾占比，选择垃圾最多的 Region 作为 “重定位集”（优先回收效率最高的区域）。
为每个重定位集中的存活对象（颜色为 0001）分配新地址（如旧地址0x1000→新地址0x2000）。
将旧地址指针颜色改为 “待重定位（0010）”（如0010_0000_1000），新地址指针颜色设为 “已重定位（0011）”（如0011_0000_2000）。
记录 “旧地址→新地址” 映射到 Relocation Map（供后续指针修正）。
四、并发重定位（Concurrent Relocate）
目标：将重定位集中的存活对象从旧地址移动到新地址，同时允许应用线程并发访问。
颜色指针变化：

应用线程读取 “待重定位（0010）” 指针时，通过读屏障修正为 “已重定位（0011）” 的新地址。

过程：

GC 线程与应用线程并行，逐步将旧地址（0010）的对象数据复制到新地址（0011）。
应用线程访问旧地址对象时（如obj = a.b，a.b存储旧地址0x1000，颜色 0010）：
触发读屏障：检测到指针颜色为 “待重定位（0010）”。
查询 Relocation Map：找到旧地址0x1000对应的新地址0x2000。
修正指针：将a.b的指针更新为新地址0x2000，颜色改为 “已重定位（0011）”。
返回新地址：应用线程直接访问新地址对象，无感知移动过程。

核心优势：

无需 STW 暂停应用，对象移动与应用访问并行，通过读屏障实现 “旧地址自动转发到新地址”。
五、并发重映射（Concurrent Remap）
目标：异步更新所有剩余的旧地址引用，彻底清理旧地址映射。
颜色指针变化：

所有 “已重定位（0011）” 的新地址指针，颜色恢复为未标记（0000）（等待下一轮 GC）。

过程：

GC 后台线程遍历全堆，将仍指向旧地址（0010）的引用统一更新为新地址（0011）（补充读屏障未覆盖的场景）。
当所有引用都更新为新地址后，删除 Relocation Map 中的映射记录。
将新地址指针的颜色从 “已重定位（0011）” 改回 “未标记（0000）”，为下一次 GC 循环做准备。
回收旧地址所在的 Region（重定位集），标记为空闲。
六、最终标记（Final Mark，STW）
目标：处理并发标记阶段遗漏的少量根对象（如 JNI 引用、线程本地存储），确保标记完整性。
颜色指针变化：

遗漏的根对象引用的对象，颜色从未标记（0000） 改为已标记（0001）（极少数情况）。

过程：

短暂暂停应用线程（STW，几百微秒）。
扫描特殊根对象（如 JNI 全局引用），标记其直接引用的未标记对象。
恢复应用线程，整个 GC 循环结束。

3. ZGC 中颜色指针与读屏障的协作（示例）
   沿用 G1 的类结构，代码如下：

```java
public class ZGCDemo {
    public static void main(String[] args) {
        A a = new A(); // a在Region R1（地址0x1000）
        B b = new B(); // b在Region R2（地址0x3000）
        a.b = b; // a.b存储指针0x3000（指向b）

        // ZGC触发回收，将b从0x3000移动到0x4000（并发重定位阶段）
        // 应用线程读取a.b（触发读屏障）
        B b2 = a.b;
        System.out.println(b2); //期望访问新地址0x4000的b
    }
}
```
颜色指针设置：ZGC 在预备重定位阶段，将 b 的旧地址0x3000颜色设为 “待重定位”（高 4 位0010），Relocation Map 记录0x3000→0x4000。
读屏障触发：应用线程执行a.b时，读屏障检测到0x3000是 “待重定位”。
指针修正：读屏障查询 Relocation Map，将a.b的指针修正为0x4000（颜色设为 “已重定位”），应用线程最终访问新地址的 b。


## g1在年轻代用的复制算法
* 标记存活对象：从根对象出发，标记 Eden 和 Survivor Region 中所有存活的对象（主要是新创建的短期对象）。
* 复制存活对象：将所有存活对象复制到新的 Survivor Region（或晋升到老年代 Region，对于达到年龄阈值的对象）。
* 清空原区域：复制完成后，原 Eden 和 Survivor Region 被标记为 “空闲”，可重新分配给新对象。


## 垃圾回收器stw在什么时候发生，为什么zgc比g1快
* G1 通过 “STW+Remembered Set” 实现可控延迟，而 ZGC 通过 “颜色指针 + 读屏障” 实现无感知并发移动，这是两者性能差异的核心原因
* cms和g1在标记对象时都需要stw，是因为要保证并发标记时，避免用户线程对对象引用关系的修改，导致标记错误。在gc线程遍历对象对象头时，可能会和用户线程争抢对象锁。
* zgc在标记对象时不需要stw，因为zgc是通过颜色指针和读屏障来保证并发标记的准确性。

### g1的Remembered Set（RS） 和 ZGC 的 Relocation Map 
1. G1 的 Remembered Set（RS）： 长期存在（与 Region 同生命周期），只要 Region 被使用，其 RS 就需要持续维护。
2. 每次应用线程修改跨 Region 引用（如a.b = c）时，写屏障都要更新 RS，这会增加应用线程的执行时间（额外消耗 5%-15% 的 CPU）。

3. ZGC 的 Relocation Map： 只有被清理的region会有，在整理阶段由 GC 线程构建，无需应用线程参与；重定位结束后立即释放，无长期维护成本。
4. 在读对象时，如果发现指针颜色变化，读屏障查询 Relocation Map，将指针修正为对象移动后的正确地址。

### 状态标记方法
1.  ZGC 的颜色指针：
   64 位指针的高几位（如 4 位）用于存储状态（颜色），而指针本身通常存储在CPU 缓存中（应用线程频繁访问的引用会被加载到 L1/L2 缓存）。
   例如：变量a指向对象obj，a的值（指针）存放在栈内存，而栈内存通常被 CPU 缓存缓存，因此读取指针的颜色位只需访问缓存（纳秒级，约 1-10ns）。
   G1 的对象头标记：
   G1 将对象状态（如是否存活）存储在对象头中，而对象头位于堆内存。堆内存容量大，且对象分散存储，CPU 缓存很难缓存所有对象头，因此读取状态需要访问主存（微秒级，约 100-200ns）。
   两者的访问延迟相差10-100 倍。
2. 无需 “跨内存访问” 的额外开销
   ZGC 判断状态时，只需读取指针本身（已在缓存中），无需访问对象所在的堆内存，避免了 “从缓存到主存” 的耗时加载。
   G1 判断状态时，必须先通过指针找到堆中的对象，再读取对象头的标记位，这需要至少一次 “指针→堆内存” 的跨区域访问（耗时且可能触发缓存未命中）。
3. 并发场景下的无锁优势
   ZGC 的颜色位修改是对指针的直接操作，而指针通常是线程私有的（如局部变量的引用），修改时无需加锁或同步（无并发冲突）。
   G1 的对象头可能被多个线程同时访问（如锁竞争、GC 标记），修改标记位时可能需要加锁或使用原子操作，进一步增加开销。
