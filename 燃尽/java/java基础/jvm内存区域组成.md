## jvm内存区域划分
1. 程序计数器：
 * 记录当前线程执行的字节码指令的地址（行号），分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。
 * 线程私有（每个线程都有独立的程序计数器，互不影响）
 * 不会发生内存溢出
 * 如果线程执行的是 Java 方法，计数器记录当前字节码指令的地址；如果是 Native 方法，计数器值为Undefined。
2. 虚拟机栈
 * 描述 Java 方法执行的内存模型，存储方法的局部变量、操作数栈、动态链接、方法出口等信息。
 * 线程私有（每个线程都有独立的虚拟机栈，互不影响），与线程生命周期一致。
 * 每个方法执行时会创建一个栈帧（Stack Frame），方法调用对应栈帧入栈，方法返回对应栈帧出栈。
 * 栈帧中包含局部变量表、操作数栈、动态链接、方法返回地址等信息。
 * 局部变量表：存储基本数据类型（boolean、byte等）和对象引用（非对象本身），内存大小在编译期确定。
 * 栈深度超过虚拟机允许的范围时，抛出StackOverflowError（如递归调用无终止）。
 * 栈动态扩展时无法申请到足够内存，抛出OutOfMemoryError。
3. 本地方法栈
 * 与虚拟机栈类似，与虚拟机栈类似，但为 Native 方法（非 Java 语言实现的方法，如 C/C++）提供内存支持,存储本地方法（Native Method）执行时的局部变量、操作数栈等信息。
 * 线程私有（每个线程都有独立的本地方法栈，互不影响），与线程生命周期一致。
 * 具体实现由虚拟机厂商决定（如 HotSpot 虚拟机将本地方法栈与虚拟机栈合并）。
4. 堆
 * 存储 Java 对象实例（几乎所有对象都在这里分配内存），是 JVM 管理的内存中最大的一块。是垃圾收集器管理的主要区域.
 * 线程共享（多个线程共享同一个堆）
5. 方法区
 * 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
 * 线程共享（多个线程共享同一个方法区）
 * JDK 8 以前，HotSpot 虚拟机用 “永久代” 实现方法区；JDK 8 及以后，用 “元空间（Metaspace）” 替代永久代，元空间物理内存位于本地内存中。

### 堆内存
1、新生代<br>
* Eden 区：新对象优先分配到 Eden 区（大对象可能直接进入老年代）。
* Survivor 区：分为 From Survivor 和 To Survivor 两个大小相等的区域，用于存放 Eden 区 GC 后存活的对象。
* 存放新创建的对象（大部分对象刚创建时会分配到这里）。对象生命周期短，回收频繁，GC 效率高

2、老年代
* 存放长期存活的对象（对象生命周期长，回收频率低）。
* 新生代中多次存活的对象（默认经历 15 次 Minor GC 后进入老年代，可通过-XX:MaxTenuringThreshold调整）。大对象（超过指定大小的对象).
* 存放长期存活的对象（对象生命周期长，回收频率低）。

3、永久代 、元空间、方法区
* “永久代” 和 “元空间” 是HotSpot 虚拟机对方法区的两种具体实现方式：
JDK 8 以前，HotSpot 用 “永久代” 实现方法区，其内存分配在 JVM 堆内存中，大小受 JVM 内存限制（可通过-XX:PermSize和-XX:MaxPermSize参数控制）。
JDK 8 及以后，HotSpot 废除永久代，改用 “元空间” 实现方法区，其内存取自本地内存（Native Memory），理论上受系统可用内存限制（可通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize参数调整）。
