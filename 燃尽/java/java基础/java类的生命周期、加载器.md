## 阶段1 编译
1、首先通过编译器(javac)将.java文件编译成.class文件,这也就是跨平台的基础

## 阶段2 类加载
* 加载：类加载器将.class文件加载到内存中，通过类的全限定名查找.class文件，读取二进制字节流，转换为方法区的运行时数据结构（如类的元信息、常量池、方法代码），并在堆中生成一个java.lang.Class对象（作为方法区数据的访问入口）
* 验证：确保加载的字节码符合 JVM 规范（安全性校验）
* 准备：为类的静态变量（static） 分配内存（在方法区），并设置默认初始值（如int默认 0，boolean默认 false，引用类型默认 null）
* 解析：将常量池中的符号引用（如类名、方法名的字符串标识）转换为直接引用（内存地址或指针）。解析对象：类、接口、字段、方法等。例如，将 “java.lang.Object” 的符号引用转为其在方法区的实际内存地址。
* 初始化：实例化对象（new）、访问静态变量 / 方法、反射（Class.forName()）； 初始化子类时，父类需先初始化； 虚拟机启动时，执行主类（含main()的类）。
* 使用：核心动作：类的实例化（创建对象）、调用实例方法 / 静态方法、访问实例变量 / 静态变量等。
* 卸载：：类的Class对象被回收，方法区中该类的元数据被清除。
      卸载条件： 该类的所有实例已被回收； 加载该类的类加载器已被回收； 该类的Class对象未被任何地方引用（无法通过反射访问）。


## 类加载器
类加载器将.class文件加载到内存中，通过类的全限定名查找.class文件，读取二进制字节流，转换为方法区的运行时数据结构（如类的元信息、常量池、方法代码），并在堆中生成一个java.lang.Class对象（作为方法区数据的访问入口）

* 启动类加载器（Bootstrap ClassLoader）：负责加载Java的核心库（如rt.jar中的java.lang.*），使用C++实现，不是Java类。
* 扩展类加载器（Extension ClassLoader）：负责加载Java的扩展库（如javax.*），使用Java实现，是Java类。
* 应用程序类加载器（Application ClassLoader）：负责加载应用程序类路径上的类，使用Java实现，是Java类。
* 自定义类加载器：可以继承ClassLoader类或实现ClassLoader接口，自定义类加载逻辑。

## 双亲委派模型
* 加载器加载类时，会先委托父加载器加载，如果父加载器无法加载，才由子加载器尝试加载。
* 好处：避免同一个类被不同加载器加载（如java.lang.String，无论哪个加载器请求，最终都由启动类加载器加载，确保全 JVM 中只有一个String类），防止恶意类篡改核心类库（如自定义java.lang.String，因双亲委派会优先由启动类加载器加载核心String，恶意类无法被加载）。

## 全盘负责机制
定义：当一个类加载器负责加载某个类时，该类所依赖和引用的其他类，也由这个类加载器负责加载（除非显式指定其他类加载器）。
举例：如果应用程序类加载器加载了A.class，而A类中引用了B.class，则B.class也会由应用程序类加载器尝试加载（除非B的类加载过程被显式干预）。
作用：确保类之间的依赖关系被同一加载器管理，避免因依赖类被不同加载器加载而导致的类型不兼容问题（如ClassCastException）。

## 缓存机制
定义：类加载器加载一个类后，会将该类的Class对象缓存起来。当再次需要加载该类时，会先从缓存中查找，若存在则直接返回，不再重新加载。
细节： 缓存的是类的全限定名与Class对象的映射。 类卸载时才会清除缓存（但类卸载的条件非常严格，通常很少发生）。
作用： 提高类加载效率，避免重复加载相同的类。 保证同一个类在 JVM 中只存在一个Class对象（除非被不同类加载器加载）。

* 双亲委派解决了类加载的 “优先级” 问题，确保核心类优先加载。
* 全盘负责解决了类依赖的 “一致性” 问题，确保依赖类由同一加载器管理。
* 缓存机制解决了类加载的 “效率” 问题，避免重复加载。


## 如何破除双亲委派模型
* 双亲委派的逻辑在ClassLoader的loadClass()方法中实现，继承ClassLoader类，重写这个方法，自己定义加载逻辑。
* 使用线程上下文类加载器：Thread.setContextClassLoader() 方法可以设置当前线程的上下文类加载器。